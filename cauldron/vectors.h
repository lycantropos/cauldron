#pragma once

#include <algorithm>

#include "bases.h"


namespace cauldron {
/**
 * Strategy which generates ``std::vector`` instances
 * with sizes and elements generated from corresponding strategies.
 * @tparam Element: type of vectors elements generated by strategy.
 */
template<typename Element>
class Vectors : public CloneHelper<std::vector<Element>, Vectors<Element>> {
  using SizesStrategy = Strategy<size_t>;
  using ElementsStrategy = Strategy<Element>;
 public:
  /**
   * @param sizes: strategy to generate vectors sizes from.
   * @param elements: strategy to generate vectors elements from.
   */
  Vectors(const SizesStrategy &sizes,
          const ElementsStrategy &elements) :
      sizes_(sizes.clone()),
      elements_(elements.clone()) {};

  /**
   * Default copy constructor doesn't fit
   * since we're using ``std::unique_ptr`` as class members
   * which is not copyable.
   */
  Vectors(const Vectors<Element> &vectors) :
      sizes_(vectors.sizes_->clone()),
      elements_(vectors.elements_->clone()) {};

  /**
   * Generates pseudo-random ``std::vector`` instance.
   */
  std::vector<Element> operator()() const override {
    size_t size = (*sizes_)();
    std::vector<Element> result(size);
    // FIXME: workaround using lambda to get producer from strategy
    auto elements_producer = [&]() -> Element {
      return (*elements_)();
    };
    std::generate_n(result.begin(),
                    size,
                    elements_producer);
    return result;
  }

 private:
  std::unique_ptr<SizesStrategy> sizes_;
  std::unique_ptr<ElementsStrategy> elements_;
};
}
