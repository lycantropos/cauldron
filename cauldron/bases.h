#pragma once

#include <functional>
#include <memory>
#include "sieve.h"
#include "facility.h"


namespace strategies {
template<typename T>
class Filtered;


template<typename T>
class Mapped;


/**
 * Strategies base class.
 *
 * Hereafter a **strategy** is an object
 * which encapsulates an algorithm
 * for generating specific type of data.
 * @tparam T: type of data generated by strategy.
 */
template<typename T>
class Strategy {
 public:
  /**
   * Generates data.
   */
  virtual T operator()() const = 0;

  /**
   * Returns a new strategy
   * that generates data from the strategy
   * modified with provided ``strategies::Converter`` instance.
   */
  virtual std::unique_ptr<Mapped<T>> map(
      const Converter<T> &converter
  ) const {
    auto facility = Facility<T>().expand(converter);
    return std::make_unique<Mapped<T>>(facility,
                                       std::move(clone()));
  }

  /**
   * Returns a new strategy
   * that generates data from the strategy
   * which satisfy provided ``strategies::Requirement`` instance.
   *
   * Note that if the ``requirement`` is too hard to satisfy
   * this might result in failing with ``OutOfCycles``.
   */
  virtual std::unique_ptr<Filtered<T>> filter(
      const Requirement<T> &requirement
  ) const {
    auto sieve = Sieve<T>().expand(requirement);
    return std::make_unique<Filtered<T>>(sieve,
                                         std::move(clone()));
  }

  /**
   * Creates a copy of the strategy instance
   * and returns pointer to it.
   */
  virtual std::unique_ptr<Strategy<T>> clone() const = 0;
};


/**
 * Helper class for implementing ``Strategy::clone`` method
 * using
 * <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">
 * curiously recurring template pattern
 * </a>.
 * @tparam T: type of data generated by strategy.
 * @tparam Derived: derivative strategy class.
 */
template<typename T, class Derived>
class CloneHelper : public Strategy<T> {
 public:
  std::unique_ptr<Strategy<T>> clone() const override {
    return std::make_unique<Derived>(static_cast<const Derived &>(*this));
  }
};


/**
 * Strategy which filters out data
 * that satisfies defined ``strategies::Requirement`` instances.
 *
 * Hereafter a **requirement** is an
 * <a href="https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)">
 * unary predicate
 * </a>.
 * @tparam T: type of data generated by strategy.
 */
template<typename T>
class Filtered : public CloneHelper<T, Filtered<T>> {
 public:
  explicit Filtered(const Sieve<T> &sieve,
                    std::shared_ptr<Strategy<T>> strategy) :
      sieve_(sieve),
      strategy_(std::move(strategy)) {};

  std::unique_ptr<Filtered<T>> filter(
      const Requirement<T> &requirement
  ) const override {
    auto sieve = sieve_.expand(requirement);
    return std::make_unique<Filtered<T>>(sieve,
                                         strategy_);
  }

  /**
   * Generates data
   * that satisfies defined ``strategies::Requirement`` instances.
   * @throws strategies::OutOfCycles
   */
  T operator()() const override {
    std::function<T()> producer([&]() -> T {
      return (*strategy_)();
    });
    return sieve_.sift(producer);
  }

 protected:
  Sieve<T> sieve_;
  std::shared_ptr<Strategy<T>> strategy_;
};


/**
 * Strategy which modifies data
 * with defined ``strategies::Converter`` instances.
 *
 * Hereafter a **converter** is an
 * <a href="https://en.wikipedia.org/wiki/Operator_(mathematics)">
 * operator
 * </a>.
 * @tparam T: type of data generated by strategy.
 */
template<typename T>
class Mapped : public CloneHelper<T, Mapped<T>> {
 public:
  explicit Mapped(const Facility<T> &facility,
                  std::shared_ptr<Strategy<T>> strategy) :
      facility_(facility),
      strategy_(std::move(strategy)) {};

  std::unique_ptr<Mapped<T>> map(
      const Converter<T> &converter
  ) const override {
    auto facility = facility_.expand(converter);
    return std::make_unique<Mapped>(facility,
                                    strategy_);
  }

  /**
   * Generates data
   * and modifies it with defined ``strategies::Converter`` instances.
   * @throws strategies::OutOfCycles
   */
  T operator()() const override {
    T product = (*strategy_)();
    return facility_.convert(product);
  }

 protected:
  Facility<T> facility_;
  std::shared_ptr<Strategy<T>> strategy_;
};
}
