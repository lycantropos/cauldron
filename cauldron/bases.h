#pragma once

#include <functional>
#include <memory>
#include "sieve.h"
#include "facility.h"


namespace strategies {
template<typename Value>
class Filtered;


template<typename Value>
class Mapped;


/**
 * Strategies base class.
 *
 * Hereafter a **strategy** is an object
 * which encapsulates an algorithm
 * for generating specific type of data.
 * @tparam Value: type of values generated by strategy.
 */
template<typename Value>
class Strategy {
 public:
  /**
   * Generates data.
   */
  virtual Value operator()() const = 0;

  /**
   * Returns a new strategy
   * that generates values from the strategy
   * modified with provided ``strategies::Converter`` instance.
   */
  virtual std::unique_ptr<Mapped<Value>> map(
      const Converter<Value> &converter
  ) const {
    Facility<Value> facility{converter};
    return std::make_unique<Mapped<Value>>(facility,
                                           std::move(clone()));
  }

  /**
   * Returns a new strategy
   * that generates data from the strategy
   * which satisfy provided ``strategies::Requirement`` instance.
   *
   * Note that if the ``requirement`` is too hard to satisfy
   * this might result in failing with ``OutOfCycles``.
   */
  virtual std::unique_ptr<Filtered<Value>> filter(
      const Requirement<Value> &requirement
  ) const {
    Sieve<Value> sieve{requirement};
    return std::make_unique<Filtered<Value>>(sieve,
                                             std::move(clone()));
  }

  /**
   * Creates a copy of the strategy instance
   * and returns pointer to it.
   */
  virtual std::unique_ptr<Strategy<Value>> clone() const = 0;
};


/**
 * Helper class for implementing ``Strategy::clone`` method
 * using
 * <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">
 * curiously recurring template pattern
 * </a>.
 * @tparam Value: type of values generated by strategy.
 * @tparam Derived: derivative strategy class.
 */
template<typename Value, class Derived>
class CloneHelper : public Strategy<Value> {
 public:
  std::unique_ptr<Strategy<Value>> clone() const override {
    return std::make_unique<Derived>(static_cast<const Derived &>(*this));
  }
};


/**
 * Strategy which filters out values
 * that satisfies defined ``strategies::Requirement`` instances.
 *
 * Hereafter a **requirement** is an
 * <a href="https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)">
 * unary predicate
 * </a>.
 * @tparam Value: type of values generated by strategy.
 */
template<typename Value>
class Filtered : public CloneHelper<Value, Filtered<Value>> {
 public:
  explicit Filtered(const Sieve<Value> &sieve,
                    std::shared_ptr<Strategy<Value>> strategy) :
      sieve_(sieve),
      strategy_(std::move(strategy)) {};

  std::unique_ptr<Filtered<Value>> filter(
      const Requirement<Value> &requirement
  ) const override {
    auto sieve = sieve_.expand(requirement);
    return std::make_unique<Filtered<Value>>(sieve,
                                             strategy_);
  }

  /**
   * Generates value
   * that satisfies defined ``strategies::Requirement`` instances.
   * @throws strategies::OutOfCycles
   */
  Value operator()() const override {
    std::function<Value()> producer([&]() -> Value {
      return (*strategy_)();
    });
    return sieve_.sift(producer);
  }

 protected:
  Sieve<Value> sieve_;
  std::shared_ptr<Strategy<Value>> strategy_;
};


/**
 * Strategy which modifies values
 * with defined ``strategies::Converter`` instances.
 *
 * Hereafter a **converter** is an
 * <a href="https://en.wikipedia.org/wiki/Operator_(mathematics)">
 * operator
 * </a>.
 * @tparam Value: type of values generated by strategy.
 */
template<typename Value>
class Mapped : public CloneHelper<Value, Mapped<Value>> {
 public:
  explicit Mapped(const Facility<Value> &facility,
                  std::shared_ptr<Strategy<Value>> strategy) :
      facility_(facility),
      strategy_(std::move(strategy)) {};

  std::unique_ptr<Mapped<Value>> map(
      const Converter<Value> &converter
  ) const override {
    auto facility = facility_.expand(converter);
    return std::make_unique<Mapped>(facility,
                                    strategy_);
  }

  /**
   * Generates value
   * and modifies it with defined ``strategies::Converter`` instances.
   * @throws strategies::OutOfCycles
   */
  Value operator()() const override {
    Value product = (*strategy_)();
    return facility_.convert(product);
  }

 protected:
  Facility<Value> facility_;
  std::shared_ptr<Strategy<Value>> strategy_;
};
}
