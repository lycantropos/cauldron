#pragma once

#include <algorithm>
#include <set>

#include "bases.h"


namespace cauldron {
/**
 * Strategy which generates ``std::set`` instances
 * with sizes and elements generated from corresponding strategies.
 * @tparam Element: type of sets elements generated by strategy.
 */
template<typename Element>
class Sets : public CloneHelper<std::set<Element>, Sets<Element>> {
  using SizesStrategy = Strategy<size_t>;
  using ElementsStrategy = Strategy<Element>;
 public:
  /**
   * @param sizes: strategy to generate sets sizes from.
   * @param elements: strategy to generate sets elements from.
   */
  Sets(const SizesStrategy &sizes,
       const ElementsStrategy &elements) :
      sizes_(sizes.clone()),
      elements_(elements.clone()) {};

  /**
   * Default copy constructor doesn't fit
   * since we're using ``std::unique_ptr`` as class members
   * which is not copyable.
   */
  Sets(const Sets<Element> &sets) :
      sizes_((*sets.sizes_).clone()),
      elements_((*sets.elements_).clone()) {};

  /**
   * Generates pseudo-random ``std::set`` instance.
   */
  std::set<Element> operator()() const override {
    size_t size = (*sizes_)();
    std::set<Element> result;
    Requirement<Element> element_unique(
        [&result](Element value) -> bool {
          return result.find(value) == result.end();
        });
    Filtered<Element> elements = (*elements_).filter(element_unique);
    std::generate_n(std::inserter(result,
                                  result.begin()),
                    size,
                    elements);
    return result;
  }

 private:
  std::unique_ptr<SizesStrategy> sizes_;
  std::unique_ptr<ElementsStrategy> elements_;
};
}
