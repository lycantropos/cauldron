#pragma once

#include <set>
#include <algorithm>
#include <functional>
#include "bases.h"


namespace strategies {
/**
 * Strategy which generates ``std::set`` instances
 * with sizes and elements generated from corresponding strategies.
 * @tparam T: type of sets elements generated by strategy.
 */
template<typename T>
class Sets : public CloneHelper<std::set<T>, Sets<T>> {
  using ElementsStrategy = Strategy<T>;
  using SizesStrategy = Strategy<size_t>;
 public:
  /**
   * @param sizes: strategy to generate sets sizes from.
   * @param elements: strategy to generate sets elements from.
   */
  Sets(std::shared_ptr<SizesStrategy> sizes,
       std::shared_ptr<ElementsStrategy> elements) :
      sizes_(std::move(sizes)),
      elements_(std::move(elements)) {};

  /**
   * Generates pseudo-random ``std::set`` instance.
   */
  std::set<T> operator()() const override {
    size_t size = (*sizes_)();
    std::set<T> result;
    Requirement<T> element_unique([&result](T value) -> bool {
      return result.find(value) == result.end();
    });
    std::shared_ptr<ElementsStrategy> elements(
        elements_->filter(element_unique));
    // FIXME: workaround using bind to get producer from strategy
    auto elements_producer = std::bind(&ElementsStrategy::operator(),
                                       elements);
    std::generate_n(std::inserter(result,
                                  result.begin()),
                    size,
                    elements_producer);
    return result;
  }

 private:
  std::shared_ptr<SizesStrategy> sizes_;
  std::shared_ptr<ElementsStrategy> elements_;
};
}
