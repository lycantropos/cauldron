#pragma once

#include "bases.h"


namespace cauldron {
/**
 * Strategy which generates ``Object`` instances
 * with constructor arguments generated from corresponding strategies.
 *
 * \note ``Object`` should have appropriate constructor
 *  so types and order of passed strategies agree
 *  with types and order of constructor parameters
 *  or compile-time error will arise.
 * @tparam Object: type of objects generated by strategy.
 */
template<class Object, class ...Value>
class Builder : public CloneHelper<Object, Builder<Object, Value...>> {
 public:
  /**
   * @param strategy: strategy to generate constructor arguments from.
   */
  explicit Builder(const cauldron::Strategy<Value> &... strategy) :
      strategies_(std::make_tuple(strategy.clone()...)) {}

  /**
   * Default copy constructor doesn't fit
   * since we're using ``std::unique_ptr`` as class members
   * which is not copyable.
   */
  Builder(const Builder<Object, Value...> &builder) :
      strategies_(builder.clone_strategies()) {}

  /**
   * Generates pseudo-random ``Object`` instance.
   */
  Object operator()() const override {
    auto strategies_count = std::tuple_size<decltype(strategies_)>{};
    return produce(strategies_,
                   std::make_index_sequence<strategies_count>{});
  }

 private:
  std::tuple<std::unique_ptr<cauldron::Strategy<Value>>...> strategies_;

  /**
   * Helper function for unpacking ``Builder::strategies_`` tuple
   * into variadic ``Strategy`` instances.
   */
  template<std::size_t... Indices>
  Object produce(
      const std::tuple<std::unique_ptr<cauldron::Strategy<Value>>...> &strategies,
      std::index_sequence<Indices...>
  ) const {
    return produce(std::get<Indices>(strategies)...);
  }

  /**
   * Helper function for producing values
   * from variadic ``Strategy`` instances.
   */
  Object produce(
      const std::unique_ptr<cauldron::Strategy<Value>> &... strategy
  ) const {
    return Object((*strategy)()...);
  }

  std::tuple<std::unique_ptr<cauldron::Strategy<Value>>...>
  clone_strategies() const {
    auto strategies_count = std::tuple_size<decltype(strategies_)>{};
    return clone_strategies(strategies_,
                            std::make_index_sequence<strategies_count>{});
  }

  /**
   * Helper function for unpacking ``Builder::strategies_`` tuple
   * into variadic ``Strategy`` instances.
   */
  template<std::size_t... Indices>
  std::tuple<std::unique_ptr<cauldron::Strategy<Value>>...>
  clone_strategies(
      const std::tuple<std::unique_ptr<cauldron::Strategy<Value>>...> &strategies,
      std::index_sequence<Indices...>
  ) const {
    return clone_strategies(std::get<Indices>(strategies)...);
  }

  /**
   * Helper function for cloning variadic ``Strategy`` instances.
   */
  std::tuple<std::unique_ptr<cauldron::Strategy<Value>>...>
  clone_strategies(
      const std::unique_ptr<cauldron::Strategy<Value>> &... strategy
  ) const {
    return std::make_tuple((*strategy).clone()...);
  }
};
}
